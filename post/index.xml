<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://zicodeer.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jul 2020 17:53:11 +0800</lastBuildDate>
    
	<atom:link href="https://zicodeer.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java集合框架</title>
      <link>https://zicodeer.github.io/post/collection/</link>
      <pubDate>Tue, 21 Jul 2020 17:53:11 +0800</pubDate>
      
      <guid>https://zicodeer.github.io/post/collection/</guid>
      <description>1.1. 集合概述 1.1.1. Java 集合概览 从下图可以看出，在 Java 中除了以 Map 结尾的类之外， 其他类都实现了 Collection 接口。
并且，以 Map 结尾的类都实现了 Map 接口。
1.1.2. 说说 List,Set,Map 三者的区别？  List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。 Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，&amp;rdquo;y&amp;rdquo;代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。  1.1.3. 集合框架底层数据结构总结 先来看一下 Collection 接口下面的集合。
1.1.3.1. List  Arraylist： Object[]数组 Vector：Object[]数组 LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)  1.1.3.2. Set  HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet：LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的 TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)  再来看看 Map 接口下面的集合。</description>
    </item>
    
    <item>
      <title>HashMap</title>
      <link>https://zicodeer.github.io/post/blog/</link>
      <pubDate>Thu, 16 Jul 2020 08:45:35 +0800</pubDate>
      
      <guid>https://zicodeer.github.io/post/blog/</guid>
      <description>HashMap 简介 HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。
JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 treeifyBin方法。
底层数据结构分析 JDK1.8之前 JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp;amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。
JDK 1.8 HashMap 的 hash 方法源码:
JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</description>
    </item>
    
  </channel>
</rss>